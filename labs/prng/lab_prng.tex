\input{includes/lab_preamble}

\def\LabCourse{AP Computer Science A}
\def\LabNumber{04}
\def\LabTitle{PRNG Lab}

\begin{document}
	\begin{coverpages}
		\ \\[2cm]
		\begin{center}
			\huge
			\textbf{\LabTitle}

			\Large
			\LabCourse
		\end{center}

		\vspace{1.5cm}

		\begin{center}
			\includegraphics[scale=0.45]{graphics/logo_black}

			\vspace{2.5cm}

			\Large
			Name: \rule{11.5cm}{0.1pt}
		\end{center}
	\end{coverpages}

	\blankpage

	\thispagestyle{empty}
	\tableofcontents

	\pagebreak

	\section{Background}
		Within a computer system or program, a pseudo-random number generator (PRNG) is used to generate sequences of seemingly random numbers. Each PRNG is an algorithm to generate a sequence of numbers that mimic the properties of truly random numbers. They are called ``pseudo''-random because these algorithms are actually deterministic; that is, if you knew the starting value (called a generator's \emph{seed}) and the algorithm in use, you could easily predict all future numbers generated by that algorithm. Nonetheless, PRNGs in wide use today benefit from being completely mathematical in nature, meaning they are easily programmed in software, and generally very fast. Their deterministic nature can be combated by chosing different seed values and by choosing algorithms and seed values that result in long \emph{periods}. A \emph{period} of a PRNG is the length of the sequence of ``random'' numbers before repetitions occur.\\[\baselineskip]
		This lab was designed to give you some exposure to the generation of random numbers. The following example shows you how a pseudo-random number generator works to generate a sequence of seemingly random numbers. The two activities that follow will ask you to implement your own pseudo-random number generators based on historic and well-known algorithms.

		\subsection{Example}
			\EBox{A bit of chaos...}{
					Work with basic chaos theory can provide for an interesting pseudo-random number generator.\\[\baselineskip]Given $0 < x_n < 1$ and $r > 0$, the following generating formula can create a sequence of numbers that seem to jump randomly in some subinterval of $[0, 1]$ after the first few iterations.
					\[ x_{n + 1} = rx_n(1 - x_n) \]

					Here is a sequence of values for $r = 3.63$ and $x_0 = 0.47$:
					\begin{center}
						\scalebox{0.7}{
							$\{0.470000000,\ 0.904233000,\ 0.314342325,\ 0.782378356,\ 0.618052744,\ 0.856910685,\ 0.445091590,\ 0.896555791,\ \ldots\}$
						}
					\end{center}
					Because of the way that this particular algorithm works, the seed value, $x_n$ is not nearly as important as the choice in $r$. Each will generate pretty distinct sequences, regardless of the initial seed value, $x_n$.

					For instance, here is a sequence of values for $r = 3.64$ and $x_0 = 0.47$:
					\begin{center}
						\scalebox{0.7}{
							$\{0.470000000,\ 0.944089000,\ 0.200054999,\ 0.606525056,\ 0.904492644,\ 0.327401808,\ 0.834595385,\ 0.523194068,\ \ldots\}$
						}
					\end{center}
					There will be, however, som values for $r$ which do not produce good sequences of seemingly random number. Here is a sequence of values for $r = 1.3$ with, again, $x_0 = 0.47$:
					\begin{center}
						\scalebox{0.7}{
							$\{0.470000000,\ 0.323830000,\ 0.284653370,\ 0.264713578,\ 0.253032389,\ 0.245709099,\ 0.240936979,\ 0.237752257,\ 0.235593957,\ 0.234116278,\ \ldots\}$
						}
					\end{center}
					Notice that the random numbers begin exhibiting ``stable'' (non-changing) values in certain positions, with $0.23\ldots$ beginning each of the random numbers towards the end of the printed sequence. In fact, no future generated number will begin with anything else, with an increasing number of decimal positions becoming stable as the sequence progresses. In fact, spreadsheet software used to calculate these sequences shows complete repetition of the pseudo-random number by the 92$^{\text{nd}}$ iteration.
			}

	\pagebreak

	\section{Applications}
		\QBox{Why are random numbers important to the study and application of computer science?}{4cm}
		\ \\[9pt]
		\QBox{Although hardware based ``true'' random number generators are available, software-based pseudo-random number generators still remain the predominant method for generating random numbers in use today. Why do you think developers continue to rely on pseudo-random number generators?}{4cm}
		\ \\[9pt]
		\QBox{Do you think a software based ``true'' random number generator will ever be created? Explain why or why not.}{4cm}
		\ \\[9pt]
		\QBox{Why is understanding the period of a sequence of random numbers important for the study, implementation, and use of a pseudo-random number generator?}{4cm}

	\pagebreak

	\section{Activity \#1}
		\subsection{Introduction}
			In 1949, John von Neumann proposed a method for generating pseudo-random numbers known as the ``Middle-Square Method''. This method works to generate numbers in the following way:
		  \begin{enumerate}
		    \item Beginning with an $n$-digit seed number, square the current number.
		    \item Select the middle $n$-digits of the resulting number. This is the new, pseudo-random number.
		    \item Repeat the process from Step \#1, using the new number.
		  \end{enumerate}
		  Although this method does appear to generate sequences of pseudo-random numbers, it quickly fell to criticism due to relatively short periods. Nonetheless, it is an academically interesting way of generating random numbers. In this activity, you will be implementing a number of methods related to generating pseudo-random numbers using the middle-square method.
			\ \\[18pt]
		  \EBox{Example}{
			  Here is an example of using the middle-square method to generate a sequence of pseudo-random numbers. We will begin with the $4$-digit seed value $5678$.
			  \[\begin{aligned}
			    (5678)^2 &= 32\underline{2396}84\\
			    (2396)^2 &= 05\underline{7408}16\\
			    (7408)^2 &= 54\underline{8784}64\\
			    &\ldots
			  \end{aligned}\]
			  In this case, the sequence of pseudo-random numbers would be: $\{5678, 2396, 7408, 8784, \ldots\}$, continuing until a repetition of a four-digit number would cause the sequence, or a subsequence of it, to begin again.\\[\baselineskip]
			  Note that because a sequence of $n$-digits is not always exactly centered in the resultant square, a choice needs to be made as to which $n$-digits should be selected. This occurred with the selection of $7408$ in the example above. Additionally, in order to form an $n$-digit number, numbers prefixed with as many as $n$ zeroes can be considered as part of the sequence of $n$-digit numbers (e.g., $0032$ can be considered a $4$-digit number).
			}

	  \subsection{Exercises}
	  %Implement middlesquares method...
	    \begin{enumerate}
	      \item Implement the \code{getMiddleSquare} method which takes as its parameters \code{x}, the current number in a sequence of pseudo-random numbers and \code{n}, the number of digits required for the generated number. This method should return the next number in the sequence using the middle-square method described above.
	      \item Overload \code{getMiddleSquare} to additional take as a parameter \code{N}, the number of pseudo-random numbers to generate. The method should return an array of integer values generated successively using the middle-square method.
	      \item Implement the \code{getMiddleSquarePeriod} method which will take as a parameter the beginning seed number, \code{x}, for a sequence of pseudo-random numbers generated using the middle-square method and \code{n}, the number of digits for each pseudo-random number in the sequence. This method should return the length of the sequence before any repetition occurs.
	    \end{enumerate}

  \pagebreak

	  \subsection{Questions}
	    \QBox{Find a four-digit seed number with a period of less than $10$. How did you conduct your search?}{6cm}
	    \ \\[9pt]
	    \QBox{Why does the existence of numbers such as those you discovered in Question \#5 mean that the middle-square method for generating pseudo-random number generators is not of practical use?}{6cm}

  \pagebreak

	\section{Activity \#2}
		\subsection{Introduction}
			The PRNG built into many programming languages and/or their libraries (including those accessible by Java's \code{Random} and \code{Math}) use a method known as a \emph{Linear Congruential Generator}. This technique generates the next pseudo-random number in a sequence of seemingly random numbers using the following formula:
			\[	x_{n + 1} = (kx_{n} + c)\ \mathbf{mod}\ m \]
			This method requires the selection of three parameters: $k$, $c$, and $m$ as well as an initial seed value, $x_0$. As with most pseudo-random number generators, the selection of these parameters becomes an important part of the algorithm implementation in order to generate a convincingly ``random'' sequence of numbers.
			\ \\[18pt]
			\EBox{Example}{
				Here is an example using a linear congruential generator with the following values:
				\begin{center}
					\begin{tabular}{l l l l}
						$k = 17$ & $c = 42$ & $m = 217$ & $x_0 = 72$
					\end{tabular}
				\end{center}
				These values yield the following sequence of numbers:
				\[\{72,\ 181,\ 81,\ 117,\ 78,\ 66,\ 79,\ 83,\ 151,\ 5,\ 127,\ 31,\ 135,\ 167,\ 60,\ \ldots\}\]
				Notice, however, what happens with a small change to the parameter $m$:
				\begin{center}
					\begin{tabular}{l l l l}
						$k = 17$ & $c = 42$ & $m = 216$ & $x_0 = 72$
					\end{tabular}
				\end{center}
				These values now yield the following sequence of numbers:
				\[\{72,\ 186,\ 180,\ 78,\ 72,\ 186,\ 180,\ 78,\ \ldots\}\]
				Note that once a repetition has occurred, the sequence will continue to repeat indefinitely.
			}

		\subsection{Exercises}
			\begin{enumerate}
				\item Implement the \code{getLCG} method that will take as parameters \code{k}, \code{c}, \code{m} and a current seed value, \code{x}, and returns the next value in the sequence generated by the linear congruential generator method described in the introduction.
				\item Overload the \code{getLCG} method to additionally take as a parameter \code{N}, the number of pseudo-random numbers to generate. This method should return an array of \code{N} integer values.
	      \item Implement the \code{getLCGPeriod} method which will take as parameters \code{k}, \code{c}, \code{m} and an initial seed value, \code{x}, and returns the length of the sequence before any repetition occurs.
			\end{enumerate}

	\pagebreak

		\subsection{Questions}
			\QBox{Language implementations of a linear congruential generator use large powers of $2$ as the $m$ parameter (Java, for instance, uses $2^{48}$). This allows for the generation of numbers with certain precision (say, $32$-bit integers) by truncating the generated number to the first, for instance, 32-bits. Which part of the LCG formula does this make simpler? Explain why this works.}{6cm}
			\ \\[9pt]
			\QBox{Explain how you would generate random, floating-point numbers using a linear congruential generator.}{6cm}

	\pagebreak

	\section{Final Analysis}
		\QBox{Many language-implemented pseudo-random number generators will use a different seed value each time they are called. This seed value is usually derived from some system factors, such as the current system time. What are the benefits and drawbacks to this approach?}{3.5cm}
		\ \\[9pt]
		\QBox{Languages that use the linear congruential generator method for generating pseudo-random numbers, such as Java, usually do not vary the parameters other than the initial seed value. Java, for instance, has values: $k = 25214903917$, $c = 11$, and $m = 2^{48}$. Why do you think these languages use established parameters for their LGC rather than generate them at the time of use?}{3.5cm}
		\ \\[9pt]
		\QBox{What part of implementing either the middle-square method or the linear congruential generator method for generating pseudo-random numbers did you find most challenging? How did you overcome this challenge?}{3.5cm}
		\ \\[9pt]
	  \QBox{What new programming techniques or knowledge did you learn as a result of this lab?}{3.5cm}

	\pagebreak
	\blankpage
	\pagebreak

	\section{Template Class \& Test Cases}
		\lstinputlisting[basicstyle=\small\ttfamily,tabsize=2]{files/PRNG.java}
\end{document}
